<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A macro that transforms `async` functions (and closures) into plain functions, whose return type is a boxed `Future`."><meta name="keywords" content="rust, rustlang, rust-lang, hook"><title>hook in serenity::framework::standard::macros - Rust</title><link rel="stylesheet" type="text/css" href="../../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../../../storage.js"></script><script src="../../../../crates.js"></script><noscript><link rel="stylesheet" href="../../../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../../../favicon.svg"><link rel="alternate icon" type="image/png" href="../../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../../../down-arrow.svg");}</style></head><body class="rustdoc attr"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../../../serenity/index.html'><div class='logo-container rust-logo'><img src='../../../../rust-logo.png' alt='logo'></div></a><div class="sidebar-elems"><p class="location">Other items in<br><a href="../../../index.html">serenity</a>::<wbr><a href="../../index.html">framework</a>::<wbr><a href="../index.html">standard</a>::<wbr><a href="index.html">macros</a></p><div id="sidebar-vars" data-name="hook" data-ty="attr" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input"name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../../../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Attribute Macro <a href="../../../index.html">serenity</a>::<wbr><a href="../../index.html">framework</a>::<wbr><a href="../index.html">standard</a>::<wbr><a href="index.html">macros</a>::<wbr><a class="attr" href="#">hook</a><button id="copy-path" onclick="copy_path(this)" title="copy path"><img src="../../../../clipboard.svg" width="19" height="18" alt="Copy item import" title="Copy item import to clipboard"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></span></h1><pre class="rust attr">#[hook]</pre><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A macro that transforms <code>async</code> functions (and closures) into plain functions, whose
return type is a boxed <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html"><code>Future</code></a>.</p>
<h1 id="transformation" class="section-header"><a href="#transformation">Transformation</a></h1>
<p>The macro transforms an <code>async</code> function, which may look like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">async</span> <span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">n</span>: <span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">i32</span> {
    <span class="ident">n</span> <span class="op">+</span> <span class="number">4</span>
}</pre></div>
<p>into this (some details omitted):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::future::Future</span>;
<span class="kw">use</span> <span class="ident">std::pin::Pin</span>;

<span class="kw">fn</span> <span class="ident">foo</span>(<span class="ident">n</span>: <span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">Pin</span><span class="op">&lt;</span><span class="ident">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="ident">std::future::Future</span><span class="op">&lt;</span><span class="ident">Output</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="ident">Box::pin</span>(<span class="kw">async</span> <span class="kw">move</span> {
        <span class="ident">n</span> <span class="op">+</span> <span class="number">4</span>
    })
}</pre></div>
<p>This transformation also applies to closures, which are converted more simply. For instance,
this closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">async</span> <span class="kw">move</span> <span class="op">|</span><span class="ident">x</span>: <span class="ident">i32</span><span class="op">|</span> {
    <span class="ident">x</span> <span class="op">*</span> <span class="number">2</span> <span class="op">+</span> <span class="number">4</span>
}</pre></div>
<p>is changed to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="op">|</span><span class="ident">x</span>: <span class="ident">i32</span><span class="op">|</span> {
    <span class="ident">Box::pin</span>(<span class="kw">async</span> <span class="kw">move</span> {
        <span class="ident">x</span> <span class="op">*</span> <span class="number">2</span> <span class="op">+</span> <span class="number">4</span>
    })
}</pre></div>
<h2 id="how-references-are-handled" class="section-header"><a href="#how-references-are-handled">How references are handled</a></h2>
<p>When a function contains references, their lifetimes are constrained to the returned
<a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html"><code>Future</code></a>. If the above <code>foo</code> function had <code>&amp;i32</code> as a parameter, the transformation would be
instead this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::future::Future</span>;
<span class="kw">use</span> <span class="ident">std::pin::Pin</span>;

<span class="kw">fn</span> <span class="ident">foo</span><span class="op">&lt;</span><span class="lifetime">&#39;fut</span><span class="op">&gt;</span>(<span class="ident">n</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;fut</span> <span class="ident">i32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">Pin</span><span class="op">&lt;</span><span class="ident">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="ident">std::future::Future</span><span class="op">&lt;</span><span class="ident">Output</span> <span class="op">=</span> <span class="ident">i32</span><span class="op">&gt;</span> <span class="op">+</span> <span class="lifetime">&#39;fut</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="ident">Box::pin</span>(<span class="kw">async</span> <span class="kw">move</span> {
        <span class="kw-2">*</span><span class="ident">n</span> <span class="op">+</span> <span class="number">4</span>
    })
}</pre></div>
<p>Explicitly specifying lifetimes (in the parameters or in the return type) or complex usage of
lifetimes (e.g. <code>'a: 'b</code>) is not supported.</p>
<h1 id="necessity-for-the-macro" class="section-header"><a href="#necessity-for-the-macro">Necessity for the macro</a></h1>
<p>The macro performs the transformation to permit the framework to store and invoke the functions.</p>
<p>Functions marked with the <code>async</code> keyword will wrap their return type with the <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html"><code>Future</code></a> trait,
which a state-machine generated by the compiler for the function will implement. This complicates
matters for the framework, as <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html"><code>Future</code></a> is a trait. Depending on a type that implements a trait
is done with two methods in Rust:</p>
<ol>
<li>static dispatch - generics</li>
<li>dynamic dispatch - trait objects</li>
</ol>
<p>First method is infeasible for the framework. Typically, the framework will contain a plethora
of different commands that will be stored in a single list. And due to the nature of generics,
generic types can only resolve to a single concrete type. If commands had a generic type for
their function’s return type, the framework would be unable to store commands, as only a single
<a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html"><code>Future</code></a> type from one of the commands would get resolved, preventing other commands from being
stored.</p>
<p>Second method involves heap allocations, but is the only working solution. If a trait is
object-safe (which <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html"><code>Future</code></a> is), the compiler can generate a table of function pointers
(a vtable) that correspond to certain implementations of the trait. This allows to decide
which implementation to use at runtime. Thus, we can use the interface for the <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html"><code>Future</code></a> trait,
and avoid depending on the underlying value (such as its size). To opt-in to dynamic dispatch,
trait objects must be used with a pointer, like references (<code>&amp;</code> and <code>&amp;mut</code>) or <code>Box</code>. The
latter is what’s used by the macro, as the ownership of the value (the state-machine) must be
given to the caller, the framework in this case.</p>
<p>The macro exists to retain the normal syntax of <code>async</code> functions (and closures), while
granting the user the ability to pass those functions to the framework, like command functions
and hooks (<code>before</code>, <code>after</code>, <code>on_dispatch_error</code>, etc.).</p>
<h1 id="notes" class="section-header"><a href="#notes">Notes</a></h1>
<p>If applying the macro on an <code>async</code> closure, you will need to enable the <code>async_closure</code>
feature. Inputs to procedural macro attributes must be valid Rust code, and <code>async</code>
closures are not stable yet.</p>
</div></details></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../../../" data-current-crate="serenity" data-search-index-js="../../../../search-index.js" data-search-js="../../../../search.js"></div>
    <script src="../../../../main.js"></script>
</body></html>